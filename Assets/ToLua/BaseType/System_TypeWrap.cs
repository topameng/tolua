//this source code was auto-generated by tolua#, do not modify it
using System;
using System.Runtime.InteropServices;
using LuaInterface;

public class System_TypeWrap
{
	public static void Register(LuaState L)
	{
		IntPtr lazyWrapFunc = Marshal.GetFunctionPointerForDelegate((LuaCSFunction)LazyWrap);
		IntPtr lazyVarWrapFunc = Marshal.GetFunctionPointerForDelegate((LuaCSFunction)LazyVarWrap);
		L.BeginClass(typeof(System.Type), typeof(System.Object));
		L.RegLazyFunction("Equals", lazyWrapFunc);
		L.RegLazyFunction("GetType", lazyWrapFunc);
		L.RegLazyFunction("GetTypeArray", lazyWrapFunc);
		L.RegLazyFunction("GetTypeCode", lazyWrapFunc);
		L.RegLazyFunction("GetTypeFromHandle", lazyWrapFunc);
		L.RegLazyFunction("GetTypeHandle", lazyWrapFunc);
		L.RegLazyFunction("IsSubclassOf", lazyWrapFunc);
		L.RegLazyFunction("FindInterfaces", lazyWrapFunc);
		L.RegLazyFunction("GetInterface", lazyWrapFunc);
		L.RegLazyFunction("GetInterfaceMap", lazyWrapFunc);
		L.RegLazyFunction("GetInterfaces", lazyWrapFunc);
		L.RegLazyFunction("IsAssignableFrom", lazyWrapFunc);
		L.RegLazyFunction("IsInstanceOfType", lazyWrapFunc);
		L.RegLazyFunction("GetArrayRank", lazyWrapFunc);
		L.RegLazyFunction("GetElementType", lazyWrapFunc);
		L.RegLazyFunction("GetHashCode", lazyWrapFunc);
		L.RegLazyFunction("GetNestedType", lazyWrapFunc);
		L.RegLazyFunction("GetNestedTypes", lazyWrapFunc);
		L.RegLazyFunction("GetDefaultMembers", lazyWrapFunc);
		L.RegLazyFunction("FindMembers", lazyWrapFunc);
		L.RegLazyFunction("InvokeMember", lazyWrapFunc);
		L.RegLazyFunction("ToString", lazyWrapFunc);
		L.RegLazyFunction("GetGenericArguments", lazyWrapFunc);
		L.RegLazyFunction("GetGenericTypeDefinition", lazyWrapFunc);
		L.RegLazyFunction("MakeGenericType", lazyWrapFunc);
		L.RegLazyFunction("GetGenericParameterConstraints", lazyWrapFunc);
		L.RegLazyFunction("MakeArrayType", lazyWrapFunc);
		L.RegLazyFunction("MakeByRefType", lazyWrapFunc);
		L.RegLazyFunction("MakePointerType", lazyWrapFunc);
		L.RegLazyFunction("ReflectionOnlyGetType", lazyWrapFunc);
		L.RegFunction("__tostring", ToLua.op_ToString);
		L.RegLazyVar("Delimiter", true, false, lazyVarWrapFunc);
		L.RegLazyVar("EmptyTypes", true, false, lazyVarWrapFunc);
		L.RegLazyVar("FilterAttribute", true, false, lazyVarWrapFunc);
		L.RegLazyVar("FilterName", true, false, lazyVarWrapFunc);
		L.RegLazyVar("FilterNameIgnoreCase", true, false, lazyVarWrapFunc);
		L.RegLazyVar("Missing", true, false, lazyVarWrapFunc);
		L.RegLazyVar("Assembly", true, false, lazyVarWrapFunc);
		L.RegLazyVar("AssemblyQualifiedName", true, false, lazyVarWrapFunc);
		L.RegLazyVar("Attributes", true, false, lazyVarWrapFunc);
		L.RegLazyVar("BaseType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("DeclaringType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("DefaultBinder", true, false, lazyVarWrapFunc);
		L.RegLazyVar("FullName", true, false, lazyVarWrapFunc);
		L.RegLazyVar("GUID", true, false, lazyVarWrapFunc);
		L.RegLazyVar("HasElementType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsAbstract", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsAnsiClass", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsArray", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsAutoClass", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsAutoLayout", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsByRef", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsClass", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsCOMObject", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsContextful", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsEnum", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsExplicitLayout", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsImport", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsInterface", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsLayoutSequential", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsMarshalByRef", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedAssembly", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedFamANDAssem", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedFamily", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedFamORAssem", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedPrivate", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNestedPublic", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNotPublic", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsPointer", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsPrimitive", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsPublic", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsSealed", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsSerializable", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsSpecialName", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsUnicodeClass", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsValueType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("MemberType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("Module", true, false, lazyVarWrapFunc);
		L.RegLazyVar("Namespace", true, false, lazyVarWrapFunc);
		L.RegLazyVar("ReflectedType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("TypeHandle", true, false, lazyVarWrapFunc);
		L.RegLazyVar("TypeInitializer", true, false, lazyVarWrapFunc);
		L.RegLazyVar("UnderlyingSystemType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("ContainsGenericParameters", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsGenericTypeDefinition", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsGenericType", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsGenericParameter", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsNested", true, false, lazyVarWrapFunc);
		L.RegLazyVar("IsVisible", true, false, lazyVarWrapFunc);
		L.RegLazyVar("GenericParameterPosition", true, false, lazyVarWrapFunc);
		L.RegLazyVar("GenericParameterAttributes", true, false, lazyVarWrapFunc);
		L.RegLazyVar("DeclaringMethod", true, false, lazyVarWrapFunc);
		L.RegLazyVar("StructLayoutAttribute", true, false, lazyVarWrapFunc);
		L.EndClass();
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int Equals(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2 && TypeChecker.CheckTypes<System.Type>(L, 2))
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				System.Type arg0 = (System.Type)ToLua.ToObject(L, 2);
				bool o = obj != null ? obj.Equals(arg0) : arg0 == null;
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 2 && TypeChecker.CheckTypes<object>(L, 2))
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				object arg0 = ToLua.ToVarObject(L, 2);
				bool o = obj != null ? obj.Equals(arg0) : arg0 == null;
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.Equals");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetType(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 1 && TypeChecker.CheckTypes<System.Type>(L, 1))
			{
				System.Type obj = (System.Type)ToLua.ToObject(L, 1);
				System.Type o = obj.GetType();
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 1 && TypeChecker.CheckTypes<string>(L, 1))
			{
				string arg0 = ToLua.ToString(L, 1);
				System.Type o = System.Type.GetType(arg0);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 2)
			{
				string arg0 = ToLua.CheckString(L, 1);
				bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
				System.Type o = System.Type.GetType(arg0, arg1);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 3)
			{
				string arg0 = ToLua.CheckString(L, 1);
				bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
				bool arg2 = LuaDLL.luaL_checkboolean(L, 3);
				System.Type o = System.Type.GetType(arg0, arg1, arg2);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.GetType");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetTypeArray(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			object[] arg0 = ToLua.CheckObjectArray(L, 1);
			System.Type[] o = System.Type.GetTypeArray(arg0);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetTypeCode(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type arg0 = ToLua.CheckMonoType(L, 1);
			System.TypeCode o = System.Type.GetTypeCode(arg0);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetTypeFromHandle(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.RuntimeTypeHandle arg0 = StackTraits<System.RuntimeTypeHandle>.Check(L, 1);
			System.Type o = System.Type.GetTypeFromHandle(arg0);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetTypeHandle(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			object arg0 = ToLua.ToVarObject(L, 1);
			System.RuntimeTypeHandle o = System.Type.GetTypeHandle(arg0);
			ToLua.PushValue(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsSubclassOf(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type arg0 = ToLua.CheckMonoType(L, 2);
			bool o = obj.IsSubclassOf(arg0);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int FindInterfaces(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Reflection.TypeFilter arg0 = (System.Reflection.TypeFilter)ToLua.CheckDelegate<System.Reflection.TypeFilter>(L, 2);
			object arg1 = ToLua.ToVarObject(L, 3);
			System.Type[] o = obj.FindInterfaces(arg0, arg1);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetInterface(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Type o = obj.GetInterface(arg0);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 3)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				bool arg1 = LuaDLL.luaL_checkboolean(L, 3);
				System.Type o = obj.GetInterface(arg0, arg1);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.GetInterface");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetInterfaceMap(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type arg0 = ToLua.CheckMonoType(L, 2);
			System.Reflection.InterfaceMapping o = obj.GetInterfaceMap(arg0);
			ToLua.PushValue(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetInterfaces(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type[] o = obj.GetInterfaces();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsAssignableFrom(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type arg0 = ToLua.CheckMonoType(L, 2);
			bool o = obj.IsAssignableFrom(arg0);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsInstanceOfType(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			object arg0 = ToLua.ToVarObject(L, 2);
			bool o = obj.IsInstanceOfType(arg0);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetArrayRank(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			int o = obj.GetArrayRank();
			LuaDLL.lua_pushinteger(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetElementType(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type o = obj.GetElementType();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetHashCode(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			int o = obj.GetHashCode();
			LuaDLL.lua_pushinteger(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetNestedType(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Type o = obj.GetNestedType(arg0);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 3)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Reflection.BindingFlags arg1 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 3);
				System.Type o = obj.GetNestedType(arg0, arg1);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.GetNestedType");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetNestedTypes(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 1)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				System.Type[] o = obj.GetNestedTypes();
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 2)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				System.Reflection.BindingFlags arg0 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 2);
				System.Type[] o = obj.GetNestedTypes(arg0);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.GetNestedTypes");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetDefaultMembers(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Reflection.MemberInfo[] o = obj.GetDefaultMembers();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int FindMembers(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 5);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Reflection.MemberTypes arg0 = (System.Reflection.MemberTypes)ToLua.CheckObject(L, 2, typeof(System.Reflection.MemberTypes));
			System.Reflection.BindingFlags arg1 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 3);
			System.Reflection.MemberFilter arg2 = (System.Reflection.MemberFilter)ToLua.CheckDelegate<System.Reflection.MemberFilter>(L, 4);
			object arg3 = ToLua.ToVarObject(L, 5);
			System.Reflection.MemberInfo[] o = obj.FindMembers(arg0, arg1, arg2, arg3);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int InvokeMember(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 6)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Reflection.BindingFlags arg1 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 3);
				System.Reflection.Binder arg2 = (System.Reflection.Binder)ToLua.CheckObject<System.Reflection.Binder>(L, 4);
				object arg3 = ToLua.ToVarObject(L, 5);
				object[] arg4 = ToLua.CheckObjectArray(L, 6);
				object o = obj.InvokeMember(arg0, arg1, arg2, arg3, arg4);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 7)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Reflection.BindingFlags arg1 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 3);
				System.Reflection.Binder arg2 = (System.Reflection.Binder)ToLua.CheckObject<System.Reflection.Binder>(L, 4);
				object arg3 = ToLua.ToVarObject(L, 5);
				object[] arg4 = ToLua.CheckObjectArray(L, 6);
				System.Globalization.CultureInfo arg5 = (System.Globalization.CultureInfo)ToLua.CheckObject<System.Globalization.CultureInfo>(L, 7);
				object o = obj.InvokeMember(arg0, arg1, arg2, arg3, arg4, arg5);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 9)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				string arg0 = ToLua.CheckString(L, 2);
				System.Reflection.BindingFlags arg1 = (System.Reflection.BindingFlags)LuaDLL.luaL_checknumber(L, 3);
				System.Reflection.Binder arg2 = (System.Reflection.Binder)ToLua.CheckObject<System.Reflection.Binder>(L, 4);
				object arg3 = ToLua.ToVarObject(L, 5);
				object[] arg4 = ToLua.CheckObjectArray(L, 6);
				System.Reflection.ParameterModifier[] arg5 = ToLua.CheckStructArray<System.Reflection.ParameterModifier>(L, 7);
				System.Globalization.CultureInfo arg6 = (System.Globalization.CultureInfo)ToLua.CheckObject<System.Globalization.CultureInfo>(L, 8);
				string[] arg7 = ToLua.CheckStringArray(L, 9);
				object o = obj.InvokeMember(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.InvokeMember");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ToString(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			string o = obj.ToString();
			LuaDLL.lua_pushstring(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetGenericArguments(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type[] o = obj.GetGenericArguments();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetGenericTypeDefinition(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type o = obj.GetGenericTypeDefinition();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MakeGenericType(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type[] arg0 = ToLua.CheckParamsObject<System.Type>(L, 2, count - 1);
			System.Type o = obj.MakeGenericType(arg0);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetGenericParameterConstraints(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type[] o = obj.GetGenericParameterConstraints();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MakeArrayType(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 1)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				System.Type o = obj.MakeArrayType();
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 2)
			{
				System.Type obj = ToLua.CheckMonoType(L, 1);
				int arg0 = (int)LuaDLL.luaL_checknumber(L, 2);
				System.Type o = obj.MakeArrayType(arg0);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: System.Type.MakeArrayType");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MakeByRefType(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type o = obj.MakeByRefType();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MakePointerType(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			System.Type obj = ToLua.CheckMonoType(L, 1);
			System.Type o = obj.MakePointerType();
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ReflectionOnlyGetType(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			string arg0 = ToLua.CheckString(L, 1);
			bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
			bool arg2 = LuaDLL.luaL_checkboolean(L, 3);
			System.Type o = System.Type.ReflectionOnlyGetType(arg0, arg1, arg2);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Delimiter(IntPtr L)
	{
		try
		{
			LuaDLL.lua_pushnumber(L, System.Type.Delimiter);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_EmptyTypes(IntPtr L)
	{
		try
		{
			ToLua.Push(L, System.Type.EmptyTypes);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_FilterAttribute(IntPtr L)
	{
		try
		{
			ToLua.Push(L, System.Type.FilterAttribute);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_FilterName(IntPtr L)
	{
		try
		{
			ToLua.Push(L, System.Type.FilterName);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_FilterNameIgnoreCase(IntPtr L)
	{
		try
		{
			ToLua.Push(L, System.Type.FilterNameIgnoreCase);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Missing(IntPtr L)
	{
		try
		{
			ToLua.Push(L, System.Type.Missing);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Assembly(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.Assembly ret = obj.Assembly;
			ToLua.PushObject(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index Assembly on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_AssemblyQualifiedName(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			string ret = obj.AssemblyQualifiedName;
			LuaDLL.lua_pushstring(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index AssemblyQualifiedName on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Attributes(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.TypeAttributes ret = obj.Attributes;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index Attributes on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_BaseType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Type ret = obj.BaseType;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index BaseType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_DeclaringType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Type ret = obj.DeclaringType;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index DeclaringType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_DefaultBinder(IntPtr L)
	{
		try
		{
			ToLua.PushObject(L, System.Type.DefaultBinder);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_FullName(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			string ret = obj.FullName;
			LuaDLL.lua_pushstring(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index FullName on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_GUID(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Guid ret = obj.GUID;
			ToLua.PushValue(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index GUID on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_HasElementType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.HasElementType;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index HasElementType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsAbstract(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsAbstract;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsAbstract on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsAnsiClass(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsAnsiClass;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsAnsiClass on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsArray(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsArray;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsArray on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsAutoClass(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsAutoClass;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsAutoClass on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsAutoLayout(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsAutoLayout;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsAutoLayout on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsByRef(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsByRef;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsByRef on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsClass(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsClass;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsClass on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsCOMObject(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsCOMObject;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsCOMObject on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsContextful(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsContextful;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsContextful on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsEnum(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsEnum;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsEnum on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsExplicitLayout(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsExplicitLayout;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsExplicitLayout on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsImport(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsImport;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsImport on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsInterface(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsInterface;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsInterface on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsLayoutSequential(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsLayoutSequential;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsLayoutSequential on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsMarshalByRef(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsMarshalByRef;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsMarshalByRef on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedAssembly(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedAssembly;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedAssembly on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedFamANDAssem(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedFamANDAssem;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedFamANDAssem on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedFamily(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedFamily;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedFamily on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedFamORAssem(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedFamORAssem;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedFamORAssem on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedPrivate(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedPrivate;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedPrivate on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNestedPublic(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNestedPublic;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNestedPublic on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNotPublic(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNotPublic;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNotPublic on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsPointer(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsPointer;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsPointer on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsPrimitive(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsPrimitive;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsPrimitive on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsPublic(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsPublic;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsPublic on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsSealed(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsSealed;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsSealed on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsSerializable(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsSerializable;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsSerializable on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsSpecialName(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsSpecialName;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsSpecialName on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsUnicodeClass(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsUnicodeClass;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsUnicodeClass on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsValueType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsValueType;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsValueType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_MemberType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.MemberTypes ret = obj.MemberType;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index MemberType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Module(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.Module ret = obj.Module;
			ToLua.PushObject(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index Module on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_Namespace(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			string ret = obj.Namespace;
			LuaDLL.lua_pushstring(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index Namespace on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_ReflectedType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Type ret = obj.ReflectedType;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index ReflectedType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_TypeHandle(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.RuntimeTypeHandle ret = obj.TypeHandle;
			ToLua.PushValue(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index TypeHandle on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_TypeInitializer(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.ConstructorInfo ret = obj.TypeInitializer;
			ToLua.PushObject(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index TypeInitializer on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_UnderlyingSystemType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Type ret = obj.UnderlyingSystemType;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index UnderlyingSystemType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_ContainsGenericParameters(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.ContainsGenericParameters;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index ContainsGenericParameters on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsGenericTypeDefinition(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsGenericTypeDefinition;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsGenericTypeDefinition on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsGenericType(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsGenericType;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsGenericType on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsGenericParameter(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsGenericParameter;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsGenericParameter on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsNested(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsNested;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsNested on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_IsVisible(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			bool ret = obj.IsVisible;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index IsVisible on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_GenericParameterPosition(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			int ret = obj.GenericParameterPosition;
			LuaDLL.lua_pushinteger(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index GenericParameterPosition on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_GenericParameterAttributes(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.GenericParameterAttributes ret = obj.GenericParameterAttributes;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index GenericParameterAttributes on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_DeclaringMethod(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Reflection.MethodBase ret = obj.DeclaringMethod;
			ToLua.PushObject(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index DeclaringMethod on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_StructLayoutAttribute(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			System.Type obj = (System.Type)o;
			System.Runtime.InteropServices.StructLayoutAttribute ret = obj.StructLayoutAttribute;
			ToLua.PushSealed(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index StructLayoutAttribute on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LazyWrap(IntPtr L)
	{
		try
		{
			int stackTop = LuaDLL.lua_gettop(L);
			bool lazy = LuaDLL.luaL_checkboolean(L, stackTop);
			string key = LuaDLL.lua_tostring(L, stackTop - 1);
			LuaDLL.lua_pop(L, 2);

			switch (key)
			{
				case "Equals":
					return ToLua.LazyRegisterFunc(lazy, "Equals", Equals, L);
				case "GetType":
					return ToLua.LazyRegisterFunc(lazy, "GetType", GetType, L);
				case "GetTypeArray":
					return ToLua.LazyRegisterFunc(lazy, "GetTypeArray", GetTypeArray, L);
				case "GetTypeCode":
					return ToLua.LazyRegisterFunc(lazy, "GetTypeCode", GetTypeCode, L);
				case "GetTypeFromHandle":
					return ToLua.LazyRegisterFunc(lazy, "GetTypeFromHandle", GetTypeFromHandle, L);
				case "GetTypeHandle":
					return ToLua.LazyRegisterFunc(lazy, "GetTypeHandle", GetTypeHandle, L);
				case "IsSubclassOf":
					return ToLua.LazyRegisterFunc(lazy, "IsSubclassOf", IsSubclassOf, L);
				case "FindInterfaces":
					return ToLua.LazyRegisterFunc(lazy, "FindInterfaces", FindInterfaces, L);
				case "GetInterface":
					return ToLua.LazyRegisterFunc(lazy, "GetInterface", GetInterface, L);
				case "GetInterfaceMap":
					return ToLua.LazyRegisterFunc(lazy, "GetInterfaceMap", GetInterfaceMap, L);
				case "GetInterfaces":
					return ToLua.LazyRegisterFunc(lazy, "GetInterfaces", GetInterfaces, L);
				case "IsAssignableFrom":
					return ToLua.LazyRegisterFunc(lazy, "IsAssignableFrom", IsAssignableFrom, L);
				case "IsInstanceOfType":
					return ToLua.LazyRegisterFunc(lazy, "IsInstanceOfType", IsInstanceOfType, L);
				case "GetArrayRank":
					return ToLua.LazyRegisterFunc(lazy, "GetArrayRank", GetArrayRank, L);
				case "GetElementType":
					return ToLua.LazyRegisterFunc(lazy, "GetElementType", GetElementType, L);
				case "GetHashCode":
					return ToLua.LazyRegisterFunc(lazy, "GetHashCode", GetHashCode, L);
				case "GetNestedType":
					return ToLua.LazyRegisterFunc(lazy, "GetNestedType", GetNestedType, L);
				case "GetNestedTypes":
					return ToLua.LazyRegisterFunc(lazy, "GetNestedTypes", GetNestedTypes, L);
				case "GetDefaultMembers":
					return ToLua.LazyRegisterFunc(lazy, "GetDefaultMembers", GetDefaultMembers, L);
				case "FindMembers":
					return ToLua.LazyRegisterFunc(lazy, "FindMembers", FindMembers, L);
				case "InvokeMember":
					return ToLua.LazyRegisterFunc(lazy, "InvokeMember", InvokeMember, L);
				case "ToString":
					return ToLua.LazyRegisterFunc(lazy, "ToString", ToString, L);
				case "GetGenericArguments":
					return ToLua.LazyRegisterFunc(lazy, "GetGenericArguments", GetGenericArguments, L);
				case "GetGenericTypeDefinition":
					return ToLua.LazyRegisterFunc(lazy, "GetGenericTypeDefinition", GetGenericTypeDefinition, L);
				case "MakeGenericType":
					return ToLua.LazyRegisterFunc(lazy, "MakeGenericType", MakeGenericType, L);
				case "GetGenericParameterConstraints":
					return ToLua.LazyRegisterFunc(lazy, "GetGenericParameterConstraints", GetGenericParameterConstraints, L);
				case "MakeArrayType":
					return ToLua.LazyRegisterFunc(lazy, "MakeArrayType", MakeArrayType, L);
				case "MakeByRefType":
					return ToLua.LazyRegisterFunc(lazy, "MakeByRefType", MakeByRefType, L);
				case "MakePointerType":
					return ToLua.LazyRegisterFunc(lazy, "MakePointerType", MakePointerType, L);
				case "ReflectionOnlyGetType":
					return ToLua.LazyRegisterFunc(lazy, "ReflectionOnlyGetType", ReflectionOnlyGetType, L);
			}
			return 0;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LazyVarWrap(IntPtr L)
	{
		try
		{
			int stackTop = LuaDLL.lua_gettop(L);
			bool getStatus = LuaDLL.luaL_checkboolean(L, stackTop);
			bool lazy = LuaDLL.luaL_checkboolean(L, stackTop - 1);
			string key = LuaDLL.lua_tostring(L, stackTop - 2);
			LuaDLL.lua_pop(L, 3);

			switch (key)
			{
				case "Delimiter":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Delimiter", get_Delimiter, null, L);
				case "EmptyTypes":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "EmptyTypes", get_EmptyTypes, null, L);
				case "FilterAttribute":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "FilterAttribute", get_FilterAttribute, null, L);
				case "FilterName":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "FilterName", get_FilterName, null, L);
				case "FilterNameIgnoreCase":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "FilterNameIgnoreCase", get_FilterNameIgnoreCase, null, L);
				case "Missing":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Missing", get_Missing, null, L);
				case "Assembly":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Assembly", get_Assembly, null, L);
				case "AssemblyQualifiedName":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "AssemblyQualifiedName", get_AssemblyQualifiedName, null, L);
				case "Attributes":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Attributes", get_Attributes, null, L);
				case "BaseType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "BaseType", get_BaseType, null, L);
				case "DeclaringType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "DeclaringType", get_DeclaringType, null, L);
				case "DefaultBinder":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "DefaultBinder", get_DefaultBinder, null, L);
				case "FullName":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "FullName", get_FullName, null, L);
				case "GUID":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "GUID", get_GUID, null, L);
				case "HasElementType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "HasElementType", get_HasElementType, null, L);
				case "IsAbstract":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsAbstract", get_IsAbstract, null, L);
				case "IsAnsiClass":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsAnsiClass", get_IsAnsiClass, null, L);
				case "IsArray":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsArray", get_IsArray, null, L);
				case "IsAutoClass":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsAutoClass", get_IsAutoClass, null, L);
				case "IsAutoLayout":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsAutoLayout", get_IsAutoLayout, null, L);
				case "IsByRef":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsByRef", get_IsByRef, null, L);
				case "IsClass":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsClass", get_IsClass, null, L);
				case "IsCOMObject":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsCOMObject", get_IsCOMObject, null, L);
				case "IsContextful":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsContextful", get_IsContextful, null, L);
				case "IsEnum":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsEnum", get_IsEnum, null, L);
				case "IsExplicitLayout":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsExplicitLayout", get_IsExplicitLayout, null, L);
				case "IsImport":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsImport", get_IsImport, null, L);
				case "IsInterface":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsInterface", get_IsInterface, null, L);
				case "IsLayoutSequential":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsLayoutSequential", get_IsLayoutSequential, null, L);
				case "IsMarshalByRef":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsMarshalByRef", get_IsMarshalByRef, null, L);
				case "IsNestedAssembly":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedAssembly", get_IsNestedAssembly, null, L);
				case "IsNestedFamANDAssem":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedFamANDAssem", get_IsNestedFamANDAssem, null, L);
				case "IsNestedFamily":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedFamily", get_IsNestedFamily, null, L);
				case "IsNestedFamORAssem":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedFamORAssem", get_IsNestedFamORAssem, null, L);
				case "IsNestedPrivate":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedPrivate", get_IsNestedPrivate, null, L);
				case "IsNestedPublic":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNestedPublic", get_IsNestedPublic, null, L);
				case "IsNotPublic":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNotPublic", get_IsNotPublic, null, L);
				case "IsPointer":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsPointer", get_IsPointer, null, L);
				case "IsPrimitive":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsPrimitive", get_IsPrimitive, null, L);
				case "IsPublic":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsPublic", get_IsPublic, null, L);
				case "IsSealed":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsSealed", get_IsSealed, null, L);
				case "IsSerializable":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsSerializable", get_IsSerializable, null, L);
				case "IsSpecialName":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsSpecialName", get_IsSpecialName, null, L);
				case "IsUnicodeClass":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsUnicodeClass", get_IsUnicodeClass, null, L);
				case "IsValueType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsValueType", get_IsValueType, null, L);
				case "MemberType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "MemberType", get_MemberType, null, L);
				case "Module":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Module", get_Module, null, L);
				case "Namespace":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "Namespace", get_Namespace, null, L);
				case "ReflectedType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "ReflectedType", get_ReflectedType, null, L);
				case "TypeHandle":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "TypeHandle", get_TypeHandle, null, L);
				case "TypeInitializer":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "TypeInitializer", get_TypeInitializer, null, L);
				case "UnderlyingSystemType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "UnderlyingSystemType", get_UnderlyingSystemType, null, L);
				case "ContainsGenericParameters":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "ContainsGenericParameters", get_ContainsGenericParameters, null, L);
				case "IsGenericTypeDefinition":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsGenericTypeDefinition", get_IsGenericTypeDefinition, null, L);
				case "IsGenericType":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsGenericType", get_IsGenericType, null, L);
				case "IsGenericParameter":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsGenericParameter", get_IsGenericParameter, null, L);
				case "IsNested":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsNested", get_IsNested, null, L);
				case "IsVisible":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "IsVisible", get_IsVisible, null, L);
				case "GenericParameterPosition":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "GenericParameterPosition", get_GenericParameterPosition, null, L);
				case "GenericParameterAttributes":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "GenericParameterAttributes", get_GenericParameterAttributes, null, L);
				case "DeclaringMethod":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "DeclaringMethod", get_DeclaringMethod, null, L);
				case "StructLayoutAttribute":
					return ToLua.LazyRegisterVariable(lazy, getStatus, "StructLayoutAttribute", get_StructLayoutAttribute, null, L);
			}
			return 0;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}
}

